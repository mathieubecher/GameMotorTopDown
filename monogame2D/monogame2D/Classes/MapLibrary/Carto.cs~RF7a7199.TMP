using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace monogame2D.MapLibrary
{
	public class Carto : Floor
	{

		private Map map;
		private const int nbSprite = 4;
		private bool show;
		public static List<int> fullCarto = new List<int>(){6,10};

		public bool ShowSprite { get => show; }

		/*				CONSTRUCTEUR			*/
		private Carto(Map father, string name, DimensionMap size, string texture, int[,] spriteCase, float hauteur = 0):base(father.Game, name,size, texture, nbSprite, spriteCase, hauteur)
		{
			this.show = false;
			this.map = father;
		}

		// Génération d'une carte
		public static Carto Create(Map map, string name, DimensionMap size, string texture, float hauteur = 0)
		{
			int[,] forme = new int[size.NbCaseX, size.NbCaseY];
			int[,] spriteCase = new int[size.NbCaseX, size.NbCaseY];


			// génération alléatoire de zone
			Random rng = new Random((int)DateTime.Now.Ticks);
			for (int x = 0; x < size.NbCaseX; x=x+2)
			{
				for (int y = 0; y < size.NbCaseY; y=y+2)
				{
					forme[x, y] = (rng.Next(0,10)< 8)?0:1;
					forme[x + 1, y] = forme[x, y];
					forme[x, y + 1] = forme[x, y];
					forme[x + 1, y + 1] = forme[x, y];

					spriteCase[x, y] = 0;
				}
			}

			// gestion automatique des sprites avec le contenu de forme
			for (int x = 0; x < size.NbCaseX; x++) {
				for (int y = 0; y < size.NbCaseY; y++) {
					if (forme[x, y] > 0)
					{
						spriteCase[x, y] = 6;
						// si on est pas en haut ou en bas de la carte
						if (y > 0 && y < size.NbCaseY - 1)
						{
							// HAUT
							if (forme[x, y - 1] == 0)
							{
								if ((x == 0 || forme[x - 1, y - 1] == 0) && (x == size.NbCaseX -1 || forme[x + 1, y - 1] == 0))
									spriteCase[x, y - 1] = 2;
								else
								{
									if (x == 0 || forme[x - 1, y - 1] == 0) spriteCase[x, y - 1] = 16;
									else spriteCase[x, y - 1] = 4;
								}
							}
							// BAS
							if (forme[x, y + 1] == 0)
							{
								if ((x == 0 || forme[x - 1, y + 1] == 0) && (x == size.NbCaseX - 1 || forme[x + 1, y + 1] == 0))
									spriteCase[x, y + 1] = 14;
								else
								{
									if (x == 0 || forme[x - 1, y + 1] == 0) spriteCase[x, y + 1] = 12;
									else spriteCase[x, y + 1] = 8;
								}
							}
						}

						// sin on est pas à gauche ou à droite de la carte
						if(x > 0 && x < size.NbCaseX - 1)
						{
							// GAUCHE
							if (forme[x - 1, y] == 0 && spriteCase[x - 1, y] == 0) spriteCase[x - 1, y] = 5;
							//DROITE
							if (forme[x + 1, y] == 0 && spriteCase[x + 1, y] == 0) spriteCase[x + 1, y] = 7;

						}
						// Les cases en coin
						// HAUT GAUCHE
						if(x > 0 && y > 0)
							if (forme[x - 1, y - 1] == 0 && forme[x - 1, y] == 0 && forme[x, y - 1] == 0) spriteCase[x - 1, y - 1] = 1;
						// HAUT DROITE
						if(x < size.NbCaseX -1 && y > 0)
							if (forme[x + 1, y - 1] == 0 && forme[x + 1, y] == 0 && forme[x, y - 1] == 0) spriteCase[x + 1, y - 1] = 3;
						// BAS DROITE
						if (x < size.NbCaseX - 1 && y < size.NbCaseY - 1)
							if (forme[x + 1, y + 1] == 0 && forme[x, y + 1] == 0 && forme[x + 1, y] == 0) spriteCase[x + 1, y + 1] = 15;
						// BAS GAUCHE
						if (x > 0 && y < size.NbCaseY - 1)
							if (forme[x - 1, y + 1] == 0 && forme[x - 1, y] == 0 && forme[x, y + 1] == 0) spriteCase[x - 1, y + 1] = 13;
					}
				}
			}
			Carto carto = new Carto(map, name, size, texture, spriteCase, hauteur);
			carto.Initialize();
			map.Cartos.Add(carto);

			return carto;
		}

		/*					UPDATE				*/
		public override void Update(GameTime gameTime)
		{
			// si l'objet est présent dans la fenètre
			if (map.ShowCase.X <= size.Origin.X + size.NbCaseX && map.ShowCase.X + map.ShowCase.Width >= size.Origin.X &&
				map.ShowCase.Y <= size.Origin.Y + size.NbCaseY && map.ShowCase.Y + map.ShowCase.Height >= size.Origin.Y)
			{
				// préciser qu'il est visible
				if (!show)
					show = true;
				base.Update(gameTime);
				// détermination de son ordre d'affichage
				this.DrawOrder = - this.GraphicsDevice.PresentationParameters.BackBufferWidth * this.GraphicsDevice.PresentationParameters.BackBufferHeight;
			}
			// préciser qu'il n'est pas visible
			else if (show) show = false;			
		}

		// Calcul la position réel de la carte à l'écran
		public override Rectangle RealPos()
		{
			Rectangle fatherPos = map.RealPos();
			Rectangle pos = size.RealPos();
			pos.X += fatherPos.X;
			pos.Y += fatherPos.Y;

			return pos;
		}
	}
}
